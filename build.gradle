plugins {
    id 'java'
    id 'maven-publish'

    id 'eclipse'
    id 'idea'

    id 'com.github.hierynomus.license' version '0.11.0'
    id 'com.jfrog.bintray' version '1.2'
}

version = '0.2'
description = 'Java library and Gradle plugin to remap method names after compilation'

ext {
    github = 'LapisBlue/MethodRemapper'
    url = "https://github.com/$github"

    projectName = 'MethodRemapper'
    artifactId = 'remapper'
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'maven-publish'

    apply plugin: 'eclipse'
    apply plugin: 'idea'

    apply plugin: 'license'
}

allprojects {
    group = 'blue.lapis.methodremapper'

    sourceCompatibility = 1.6
    targetCompatibility = 1.6

    repositories {
        jcenter()
    }

    license {
        header rootProject.file('LICENSE')
        include '**/*.java'
        include '**/*.groovy'

        strictCheck true
        mapping {
            java = 'SLASHSTAR_STYLE'
        }
    }

    task sourceJar(type: Jar) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }

    afterEvaluate {
        publishing {
            publications {
                mavenJava(MavenPublication) {
                    from components.java

                    if (project.tasks.findByName('javadocJar')) {
                        artifact javadocJar
                    }

                    artifact sourceJar

                    artifactId project.artifactId

                    pom.withXml {
                        def root = asNode()

                        // Ugly hack to exclude all transitve dependencies because Gradle doesn't seem to support that
                        // directly (for project dependencies)
                        def dep = root.dependencies.dependency.find {
                            it.artifactId[0].text() == 'remapper'
                        }
                        if (dep != null) {
                            dep.children().last() + {
                                // Why is this even necessary?
                                resolveStrategy = Closure.DELEGATE_FIRST

                                exclusions {
                                    exclusion {
                                        resolveStrategy = Closure.DELEGATE_FIRST

                                        groupId '*'
                                        artifactId '*'
                                    }
                                }
                            }
                        }

                        root.children().last() + {
                            // Why is this even necessary?
                            resolveStrategy = Closure.DELEGATE_FIRST

                            name project.projectName
                            description project.description

                            organization {
                                name 'Lapis'
                                url 'https://lapis.blue'
                            }

                            licenses {
                                license {
                                    name 'MIT License'
                                    url 'http://opensource.org/licenses/MIT'
                                    distribution 'repo'
                                }
                            }

                            scm {
                                url project.url
                                connection "scm:git:${project.url}.git"
                                developerConnection "scm:git:git@github.com:${github}.git"
                            }

                            issueManagement {
                                system 'github'
                                url "$project.url/issues"
                            }
                        }
                    }

                    if (!version.endsWith('-SNAPSHOT')) {
                        repositories {
                            maven {
                                url = System.getenv('REPO_RELEASES') ?: "$buildDir/repo"
                            }
                        }
                    }

                }
            }
        }
    }
}

subprojects {
    configurations {
        provided
    }

    sourceSets {
        main {
            compileClasspath += configurations.provided
        }
    }

    eclipse {
        classpath {
            plusConfigurations += [configurations.provided]
        }
    }

    idea {
        module {
            scopes.PROVIDED.plus += [configurations.provided]
        }
    }

    dependencies {
        compile(rootProject) {
            transitive = false
            exclude group: '*', module: '*'
        }
    }
}

dependencies {
    compile 'com.google.guava:guava:17.0'
    compile 'org.ow2.asm:asm:5.0.3'
    compile 'org.slf4j:slf4j-api:1.7.12'
}

javadoc {
    options.encoding = 'UTF-8'
    options.charSet = 'UTF-8'
    options.links(
            'http://www.slf4j.org/apidocs/',
            'http://docs.guava-libraries.googlecode.com/git-history/v17.0/javadoc/',
            'http://asm.ow2.org/asm50/javadoc/user/',
            'http://docs.oracle.com/javase/8/docs/api/'
    )
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

bintray {
    if (project.hasProperty('bintrayUser')) {
        user = project.bintrayUser
        key = project.bintrayKey
    }

    publications = ['mavenJava']
    pkg {
        repo = 'maven'
        name = project.projectName
        userOrg = 'lapis'
        desc = project.description
        licenses = ['MIT']

        websiteUrl = project.url
        issueTrackerUrl = "$websiteUrl/issues"
        vcsUrl = "${websiteUrl}.git"

        labels = ['remapper', 'asm']

        publicDownloadNumbers = true

        version {
            name = project.version
        }
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.6'
}
